# -*- coding: utf-8 -*-
"""bitcoin_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q_wfux5okOLf9XiYk3OXISOEaU_G9wKi
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#AIM :- predicting the highest value of Bitcoin on any day using other values such as lowest value of bitcoin, opening and closing values of bitcoin as parameters.

data=pd.read_csv('/content/BTC-USD.csv')
data

data=data.tail(1000) # selecting the data of the most recent 1000 days whose data is available
data

data.dropna() #dropping null data

data.corr() #checking columns which have the most relation to the highest value of bitcoin

data=data.iloc[:,0:5] # removing the volume column as it does not have a strong relation to the highest value and removing Adj Close column as it does not differ much from Close
data

corr=data.corr() #this is a heatmap which shows the correlation of different columns in the form of a graph
sns.heatmap(corr, cmap='coolwarm')

data['Date'].is_unique #checking if there are any cases of multiple data for same day

sns.jointplot(x='High', y='Open',data=data ) #comparing the values of other columns vs Highest value of bitcoin

sns.jointplot(x='High', y='Low',data=data )

sns.jointplot(x='High', y='Close',data=data )

x = data['Open']
y= data['High']
z = data['Close']
fig, ax = plt.subplots(subplot_kw={'projection':'3d'})
ax.scatter(x,y,z)
plt.show()

data.iloc[:,1:] = data.iloc[:,1:].apply(lambda x: (x-x.mean())/ x.std(), axis=0) # we normalise the entire data set which is basically the organization of data to appear similar across all fields.
data

from sklearn import linear_model # this module is used to implement simple linear and multiple linear regression, in this case multiple linear

z=data[['Open','Low','Close']] #this is our independant data
y=data['High'] #this is the data we are trying to predict
from sklearn.model_selection import train_test_split

SEED=20 #this is used to divide our data into training data which we use to train the model with and test data which we used to test our model
z_train,z_test,y_train,y_test = train_test_split(z,y,test_size=0.2,random_state=SEED)

mod=linear_model.LinearRegression() # here, we are trying to find a line which passes through the middle of the dataset
mod.fit(z_train,y_train)

print(mod.intercept_,mod.coef_) #this finds the y intercept of the linear regression line and the different coefficients of the three different features

y_pred=mod.predict(z_test) #we are assigning the values of predicted data to the variable y_predict

results= pd.DataFrame({'ACTUAL VALUE': y_test, 'PREDICTED VALUE':y_pred}) #comparing the values of the actual value and the predicted value
print(results)

from sklearn.metrics import mean_squared_error as msqe # this module helps us find the mean squared error of the model
mse=msqe(y_test,y_pred)
print('The mean squared error value is',mse)

amp=sum((y_test-y_pred)**2)# this formula helps us find the R^2 value of the model
ama=sum((y_test-y_test.mean())**2)
r2_value= 1 - amp/ama
print('the R^2 value of the model is ',r2_value)